// src/index.ts
import fs from "fs";
import path from "path";
import { glob } from "glob";
import ts from "typescript";
import { minimatch } from "minimatch";

// Types
export type SearchResult = {
  path: string;
  content: string;
};

interface SearchIndexEntry {
  path: string;
  content: string;
}

const EXCLUDED_PATHS = [
  "src/components/pages/aides/SubSide/radio-group",
  "src/components/pages/aides/SubSide/slider",
  "src/components/theme-provider.tsx",
  "**/ui/**",
];

function parseTSX(content: string) {
  const sourceFile = ts.createSourceFile(
    "temp.tsx",
    content,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TSX
  );
  return sourceFile;
}

function searchInFile(filePath: string, searchTerm: string): string[] {
  try {
    const content = fs.readFileSync(filePath, "utf-8");
    const matches: string[] = [];

    if (filePath.endsWith(".js") || filePath.endsWith(".jsx")) {
      const regex = new RegExp(searchTerm, "gi");
      const match = content.match(regex);
      if (match) {
        matches.push(...match);
      }
    } else {
      const sourceFile = parseTSX(content);
      const visitNode = (node: ts.Node) => {
        if (ts.isJsxText(node)) {
          const text = node.text.trim();
          if (
            text &&
            (searchTerm === "" ||
              text.toLowerCase().includes(searchTerm.toLowerCase()))
          ) {
            matches.push(text);
          }
        }
        if (
          ts.isJsxAttribute(node) &&
          node.initializer &&
          ts.isStringLiteral(node.initializer)
        ) {
          const value = node.initializer.text;
          if (
            searchTerm === "" ||
            value.toLowerCase().includes(searchTerm.toLowerCase())
          ) {
            if (ts.isIdentifier(node.name)) {
              matches.push(`${node.name.text}="${node.initializer.text}"`);
            }
          }
        }
        ts.forEachChild(node, visitNode);
      };
      visitNode(sourceFile);
    }

    return matches;
  } catch (error) {
    console.error(
      `Error processing file ${filePath}:`,
      error instanceof Error ? error.message : String(error)
    );
    return [];
  }
}

function isPathExcluded(filePath: string): boolean {
  const normalized = filePath.replace(/\\/g, "/");
  return EXCLUDED_PATHS.some((pattern) =>
    minimatch(normalized, pattern, { matchBase: true })
  );
}

function searchProject(searchTerm = ""): SearchResult[] {
  const results: SearchResult[] = [];
  const failedFiles: string[] = [];

  const files = glob.sync(path.join("src/components/**/*.{js,jsx,ts,tsx}"), {
    absolute: true,
  });

  for (const file of files) {
    const normalizedFile = file.replace(/\\/g, "/");

    if (isPathExcluded(normalizedFile)) {
      continue;
    }

    try {
      const matches = searchInFile(file, searchTerm);
      for (const match of matches) {
        results.push({
          path: path.relative(process.cwd(), file),
          content: match,
        });
      }
    } catch (error) {
      failedFiles.push(file);
      console.error(`Error processing file ${file}:`, error);
    }
  }

  if (failedFiles.length > 0) {
    console.log(`Failed files: ${failedFiles.join(", ")}`);
  }

  return results;
}

export function generateSearchIndex(): SearchIndexEntry[] {
  const searchTerm = "";
  const results = searchProject(searchTerm);

  const outputPath = path.join(process.cwd(), "src/data", "search-index.json");
  const dataDir = path.dirname(outputPath);

  if (!fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir, { recursive: true });
  }

  fs.writeFileSync(outputPath, JSON.stringify(results, null, 2));
  console.log(`‚úÖ search-index.json generated with ${results.length} entries`);

  return results;
}

export function generateComponentMap(entries: SearchIndexEntry[]) {
  const outPath = path.resolve("src/data/componentMap.ts");
  const dataDir = path.dirname(outPath);
  if (!fs.existsSync(dataDir)) {
    fs.mkdirSync(dataDir, { recursive: true });
  }

  const tsxPaths = Array.from(
    new Set(
      entries.map((entry) => entry.path).filter((p) => p.endsWith(".tsx"))
    )
  );

  const hasDefaultExport = (filePath: string): boolean => {
    try {
      const fullPath = path.resolve(filePath);
      const content = fs.readFileSync(fullPath, "utf-8");
      return /export\s+default\s+/.test(content);
    } catch (err) {
      console.warn(`‚ö†Ô∏è  Failed to read file: ${filePath}`, err);
      return false;
    }
  };

  const validPaths = tsxPaths
    .filter((p) => hasDefaultExport(path.resolve(p)))
    .map((p) => p.replace(/^src\//, "").replace(/\.tsx$/, ""))
    .sort();

  const componentMap = `
// Auto-generated by react-component-search
import type { ComponentType } from "react";

export const componentMap: Record<string, () => Promise<{ default: ComponentType<any> }>> = {
${validPaths.map((p) => `  "${p}": () => import("@/${p}")`).join(",\n")}
};
  `.trim();

  fs.writeFileSync(outPath, componentMap, "utf-8");
  console.log(`‚úÖ componentMap generated with ${validPaths.length} entries`);
}

export function buildIndexes() {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`\nüîÑ Building indexes at ${timestamp}...`);

  try {
    const searchResults = generateSearchIndex();
    generateComponentMap(searchResults);
    console.log(`‚ú® All indexes built successfully at ${timestamp}`);
  } catch (error) {
    console.error("‚ùå Error building indexes:", error);
  }
}
export * from "./hooks/use-searchDynamicImport";
export * from "./hooks/use-searchContent";
export * from "./hooks/use-searchResult";
export * from "./hooks/use-searchApi";
export * from "./hooks/use-search";
export * from "./api";
